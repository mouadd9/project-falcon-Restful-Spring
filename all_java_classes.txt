=== File: src/main/java/com/falcon/falcon/config/RedisConfig.java ===
package com.falcon.falcon.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);

        // Use String serializer for keys
        template.setKeySerializer(new StringRedisSerializer());
        // Use JSON serializer for values (optional)
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());

        return template;
    }
}


=== File: src/main/java/com/falcon/falcon/config/StateConfig.java ===
package com.falcon.falcon.config;

import com.falcon.falcon.enums.InstanceStateEnum;
import com.falcon.falcon.statePattern.InstanceState;
import com.falcon.falcon.statePattern.impl.NotStartedState;
import com.falcon.falcon.statePattern.impl.PausedState;
import com.falcon.falcon.statePattern.impl.RunningState;
import com.falcon.falcon.statePattern.impl.TerminatedState;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

// this class will provide a bean, this bean is a map that maps InstanceStateEnum values to Concrete Implementations of the InstanceState Interface
// each State Object "Concrete impl" describes the behavior of an instance in a particular state.
@Configuration
public class StateConfig {

    private NotStartedState notStartedState;
    private PausedState pausedState;
    private RunningState runningState;
    private TerminatedState terminatedState;

    public StateConfig(NotStartedState notStartedState, PausedState pausedState, RunningState runningState, TerminatedState terminatedState) {
        this.notStartedState = notStartedState;
        this.pausedState = pausedState;
        this.runningState = runningState;
        this.terminatedState = terminatedState;
    }

    @Bean
    public Map<InstanceStateEnum, InstanceState> stateMap(
            NotStartedState notStartedState,
            RunningState runningState,
            PausedState pausedState,
            TerminatedState terminatedState) {
        Map<InstanceStateEnum, InstanceState> map = new HashMap<>();
        map.put(InstanceStateEnum.NOT_STARTED, notStartedState);
        map.put(InstanceStateEnum.RUNNING, runningState);
        map.put(InstanceStateEnum.PAUSED, pausedState);
        map.put(InstanceStateEnum.TERMINATED, terminatedState);
        return map;
    }
}



=== File: src/main/java/com/falcon/falcon/controller/AuthController.java ===
package com.falcon.falcon.controller;

import com.falcon.falcon.dto.*;
import com.falcon.falcon.service.AuthService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

// this controller will cover auth related endpoints
// POST /auth/login application/json Credentials
// POST /auth/verification-codes application/json VerificationCodeRequest
// POST /auth/sign-up application/json SignUpRequest

@RestController
@RequestMapping("/auth")
public class AuthController {

    private AuthService authService;
    private AuthenticationManager authenticationManager;


    public AuthController(AuthService authService, AuthenticationManager authenticationManager) {
        this.authService = authService;
        // Type:  Interface (often implemented by ProviderManager)
        // Purpose: Manages the authentication process
        // Scope: High-level, delegates to providers ( providers are Low-level they do the actual authentication against a database)
        // Responsibility: Authentication Managers Decide Who authenticates (Authentication Providers Decide How to authenticate)
        this.authenticationManager = authenticationManager;
    }

    // login will authenticate the user and issue a jwt
    // we will inject an authentication service.
    // and we will inject a jwt generator service here.

    @PostMapping("/login")
    public ResponseEntity<Map<String, String>> login(@RequestBody LoginRequest credentials) {
        // we create an authentication token
        Authentication authentication = new UsernamePasswordAuthenticationToken(
                credentials.getUsername(),
                credentials.getPassword()
        );
        // we Authenticate with AuthenticationManager (that uses an Authentication provider in our case DaoAuthenticationProvider)
        Authentication result = authenticationManager.authenticate(authentication);

        // Set the authenticated user in the SecurityContext (optional for API)
        // SecurityContextHolder.getContext().setAuthentication(result);
        return new ResponseEntity<>(authService.generateAccessToken(result), HttpStatus.OK);
    }

    @PostMapping("/verification-codes")
    public ResponseEntity<VerificationCodeResponse> sendVerificationCode(@RequestBody VerificationCodeRequest verificationCodeRequest) {
        VerificationCodeResponse verificationCodeResponse = this.authService.requestVerificationCode(verificationCodeRequest);
        return new ResponseEntity<>(verificationCodeResponse, HttpStatus.CREATED);
    }

    // POST /auth/signup
    @PostMapping("/signup")
    public ResponseEntity<Map<String, String>> signup(@RequestBody SignUpRequest signUpRequest) {
        // verify request --> save new user
        UserDTO savedUser = this.authService.completeRegistration(signUpRequest);

        Authentication authentication = new UsernamePasswordAuthenticationToken(
                signUpRequest.getUsername(),
                signUpRequest.getPassword()
        );
        // authenticate user
        Authentication result = authenticationManager.authenticate(authentication);

        return new ResponseEntity<>(authService.generateAccessToken(result), HttpStatus.CREATED);
    }
}



=== File: src/main/java/com/falcon/falcon/controller/GlobalExceptionHandler.java ===
package com.falcon.falcon.controller;

import com.falcon.falcon.dto.ErrorResponse;
import com.falcon.falcon.exceptions.*;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;
import org.springframework.security.core.AuthenticationException;

// Marks the class as a global exception handler specifically for REST controllers
// Combines @ControllerAdvice and @ResponseBody
// @ResponseBody : is used to indicate that the return value of a method should be bound to the web response body. It tells Spring to serialize the return value directly to the HTTP response body, rather than being interpreted as a view name or model attribute.
/*
@Controller + @ResponseBody = @RestController
@ControllerAdvice + @ResponseBody = @RestControllerAdvice
*/
@RestControllerAdvice
public class GlobalExceptionHandler {
    // AUTH controller exceptions
    // here we will handle each Exception throws by the controller or other service class
    @ExceptionHandler(UserAlreadyExistsException.class)
    public ResponseEntity<ErrorResponse> handleUserAlreadyExistsException(UserAlreadyExistsException ex, WebRequest request) {
        ErrorResponse errorResponse = new ErrorResponse(
                      HttpStatus.CONFLICT.value(), // 409
                "USER_ALREADY_EXISTS",
                      ex.getMessage(), // An account with this email already exists
                      request.getDescription(false)
        );
        // ResponseEntity represents an HTTP response : status code and body
        return new ResponseEntity<>(errorResponse, HttpStatus.CONFLICT);
    }

    // Handler for CodeExpiredException
    @ExceptionHandler(CodeExpiredException.class)
    public ResponseEntity<ErrorResponse> handleCodeExpiredException(CodeExpiredException ex, WebRequest request) {
        ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(), // 400
                "CODE_EXPIRED_OR_WRONG_REQUEST",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Handler for VerificationCodeInvalid
    @ExceptionHandler(VerificationCodeInvalid.class)
    public ResponseEntity<ErrorResponse> handleVerificationCodeInvalid(VerificationCodeInvalid ex, WebRequest request) {
        ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(), // 409
                "INVALID_CODE",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Handler for EmaiNotVerifiedOrRequestIdNotValid (note the typo in the exception name)
    @ExceptionHandler(EmaiNotVerifiedOrRequestIdNotValid.class)
    public ResponseEntity<ErrorResponse> handleEmailNotVerifiedOrRequestIdNotValid(EmaiNotVerifiedOrRequestIdNotValid ex, WebRequest request) {
        ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                "EMAIL_REQUEST_MISMATCH",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Handler for RoleNotFoundException
    @ExceptionHandler(RoleNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleRoleNotFoundException(RoleNotFoundException ex, WebRequest request) {
        ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error: Role not found",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    // AuthenticationException
    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex, WebRequest request) {
        ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.UNAUTHORIZED.value(), // 401
                "AUTHENTICATION_FAILED",
                ex.getMessage(),
                request.getDescription(false)
        );

        // Return the ResponseEntity with the error response and HTTP 401 status
        return new ResponseEntity<>(errorResponse, HttpStatus.UNAUTHORIZED);
    }

    // Room Controller exception handlers
    @ExceptionHandler(RoomNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleRoomNotFoundException(AuthenticationException ex, WebRequest request) {
        ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.NOT_FOUND.value(), // 401
                "ROOM_NOT_FOUND",
                ex.getMessage(),
                request.getDescription(false)
        );

        // Return the ResponseEntity with the error response and HTTP 401 status
        return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(RoomAlreadySavedException.class)
    public ResponseEntity<ErrorResponse> handleRoomAlreadySavedException(AuthenticationException ex, WebRequest request) {
        ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.CONFLICT.value(), // 401
                "ROOM_ALREADY_SAVED",
                ex.getMessage(),
                request.getDescription(false)
        );

        // Return the ResponseEntity with the error response and HTTP 401 status
        return new ResponseEntity<>(errorResponse, HttpStatus.CONFLICT);
    }

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFoundException(AuthenticationException ex, WebRequest request) {
        ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.NOT_FOUND.value(), // 401
                "USER_NOT_FOUND",
                ex.getMessage(),
                request.getDescription(false)
        );

        // Return the ResponseEntity with the error response and HTTP 401 status
        return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
    }




}



=== File: src/main/java/com/falcon/falcon/controller/RoomController.java ===
package com.falcon.falcon.controller;

import com.falcon.falcon.dto.RoomDTO;
import com.falcon.falcon.service.RoomService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/rooms")
public class RoomController {
    private RoomService roomService;
    public RoomController(RoomService roomService) {
        this.roomService = roomService;
    }
    // GET /rooms
    @GetMapping
    public ResponseEntity<List<RoomDTO>> getAllRooms() {
        List<RoomDTO> rooms = roomService.getAllRooms();
        return new ResponseEntity<>(rooms, HttpStatus.OK);
    }

    // GET /rooms/{id} RequestBody RoomDTO
    @GetMapping("/{roomId}")
    public ResponseEntity<RoomDTO> getRoomById(@PathVariable Long roomId) {
        RoomDTO roomDTO = roomService.getRoomById(roomId);
        return new ResponseEntity<>(roomDTO, HttpStatus.OK);
    } // this may generate an exception if the room does not exist (RoomNotFoundException)

    // POST /rooms RequestBody RoomDTO
    @PostMapping
    public ResponseEntity<RoomDTO> createRoom(@RequestBody RoomDTO roomDTO) {
        RoomDTO createdRoom = roomService.createRoom(roomDTO);
        return new ResponseEntity<>(createdRoom, HttpStatus.CREATED);
    } // this may generate an exception if the room already exists (RoomAlreadySavedException); the AIM and task definition name already exists

}



=== File: src/main/java/com/falcon/falcon/controller/UserController.java ===
package com.falcon.falcon.controller;

import com.falcon.falcon.dto.RoomDTO;
import com.falcon.falcon.entity.Room;
import com.falcon.falcon.facadePattern.DomainFacade;
import com.falcon.falcon.service.UserRoomService;
import com.falcon.falcon.service.UserService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
public class UserController {

    private final DomainFacade domainFacade;
    private UserRoomService userRoomService;

    public UserController(DomainFacade domainFacade, UserService userService, UserRoomService userRoomService) {
        this.domainFacade = domainFacade;
        this.userRoomService = userRoomService;
    }
    // GET /users/1/rooms get all rooms for user with id 1
    // The client sends a GET request, e.g., GET /users/123/rooms.
    //The server uses userId (123) to fetch all rooms and adds a status field for each room based on the user’s relationship (e.g., joined or not).
    @GetMapping("/{userId}/rooms")
    public ResponseEntity<List<RoomDTO>> getUserRooms(@PathVariable long userId) {
        List<RoomDTO> rooms = domainFacade.getRoomCatalogForUser(userId);
        return new ResponseEntity<>(rooms, HttpStatus.OK);
    }

    // GET /users/{userId}/joined-rooms
    // this endpoint returns a list of joined rooms for a user, each joined room has membership details
    @GetMapping("/{userId}/joined-rooms")
    public ResponseEntity<List<RoomDTO>> getJoinedRooms(@PathVariable long userId) {
        List<RoomDTO> rooms = userRoomService.getJoinedRooms(userId);
        return new ResponseEntity<>(rooms, HttpStatus.OK);
    }

    // GET /users/{userId}/bookmarked-rooms
    // this endpoint returns a list of bookmarked rooms for a user, each bookmarked room has membership details
    @GetMapping("/{userId}/saved-rooms")
    public ResponseEntity<List<RoomDTO>> getSavedRooms(@PathVariable long userId) {
        List<RoomDTO> rooms = userRoomService.getSavedRooms(userId);
        return new ResponseEntity<>(rooms, HttpStatus.OK);
    }

    // GET /users/{userId}/completed-rooms
    // this endpoint returns a list of completed rooms for a user, each completed room has membership details
    @GetMapping("/{userId}/completed-rooms")
    public ResponseEntity<List<RoomDTO>> getCompletedRooms(@PathVariable long userId) {
        List<RoomDTO> rooms = userRoomService.getCompletedRooms(userId);
        return new ResponseEntity<>(rooms, HttpStatus.OK);
    }

    // GET /users/{userId}/joined-room/{roomId}
    // this endpoint returns user specific details about a joined room
    @GetMapping("/{userId}/joined-room/{roomId}")
    public ResponseEntity<RoomDTO> getJoinedRoom(@PathVariable long userId, @PathVariable long roomId) {
        RoomDTO room = userRoomService.getJoinedRoom(userId, roomId);
        return new ResponseEntity<>(room, HttpStatus.OK);
    }

    // a user can get info about a joined room
    // a user can join a room
    // POST /users/{userId}/rooms/{roomId}/join
    @PostMapping("/{userId}/rooms/{roomId}/join")
    public ResponseEntity<Void> joinRoom(@PathVariable long userId, @PathVariable long roomId) {
        userRoomService.joinRoom(userId, roomId);
        return ResponseEntity.ok().build();
    }

    // a user can save a room
    // POST /users/{userId}/rooms/{roomId}/save
    @PostMapping("/{userId}/rooms/{roomId}/save")
    public ResponseEntity<Void> saveRoom(@PathVariable long userId, @PathVariable long roomId) {
        userRoomService.saveRoom(userId, roomId);
        return ResponseEntity.ok().build();
    }

}



=== File: src/main/java/com/falcon/falcon/dto/ChallengeDTO.java ===
package com.falcon.falcon.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ChallengeDTO {
    private Long id;
    private String flag;
    private String name;
    private String title;
    private String description;
    private boolean isCompleted;
}



=== File: src/main/java/com/falcon/falcon/dto/ErrorResponse.java ===
package com.falcon.falcon.dto;

import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;
@Getter
@Setter
public class ErrorResponse {
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
    // Constructors
    public ErrorResponse() {
        this.timestamp = LocalDateTime.now();
    }

    public ErrorResponse(int status, String error, String message, String path) {
        this();
        this.status = status;
        this.error = error;
        this.message = message;
        this.path = path;
    }

}



=== File: src/main/java/com/falcon/falcon/dto/InstanceDTO.java ===
package com.falcon.falcon.dto;

import com.falcon.falcon.enums.InstanceStateEnum;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class InstanceDTO {
    private Long id;

    private String ipAddress;
    private String instanceId;
    private Date launchDate;
    private Date expirationDate;
    private InstanceStateEnum instanceState;
}



=== File: src/main/java/com/falcon/falcon/dto/LoginRequest.java ===
package com.falcon.falcon.dto;

import lombok.Data;

@Data
public class LoginRequest {
    String username;
    String password;
}



=== File: src/main/java/com/falcon/falcon/dto/RoomDTO.java ===
package com.falcon.falcon.dto;

import com.falcon.falcon.enums.Complexity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;
import java.util.List;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class RoomDTO {
    // room related info
      // when the user consults the catalog of rooms this shows up
    private Long id;
    private String amiId;
    private String title;
    private String description;
    private Complexity complexity; // the complexity
    private String imageURL; // the image of the room
    private int estimatedTime; // the estimated time to complete the room
    private int totalChallenges; // total challenges
    // when the user selects a room to see its details this adds up
    private List<ChallengeDTO> challenges; // List of challenges the user can see
    private int totalRunningInstances; // the Number of running instances (these two change over time via sockets)
    private int totalJoinedUsers; // the Number of joined rooms (these two change over time via sockets)
    // user related info
    private Boolean isSaved;
    private Boolean isJoined;
    private int percentageCompleted;
}



=== File: src/main/java/com/falcon/falcon/dto/SignUpRequest.java ===
package com.falcon.falcon.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor @AllArgsConstructor
public class SignUpRequest {
    String requestId;
    String code;
    String email;
    String username;
    String password;
}



=== File: src/main/java/com/falcon/falcon/dto/UserDTO.java ===
package com.falcon.falcon.dto;

import com.falcon.falcon.entity.Role;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collection;

@Data
@NoArgsConstructor @AllArgsConstructor
public class UserDTO {
    private Long id;
    private String email;
    private String username;
    private String password;
    private Collection<Role> roles; // Add this field
} // this Object will be returned and used to generate the jwt.



=== File: src/main/java/com/falcon/falcon/dto/VerificationCodeRequest.java ===
package com.falcon.falcon.dto;

import lombok.Data;

@Data
public class VerificationCodeRequest {
    String email;
}



=== File: src/main/java/com/falcon/falcon/dto/VerificationCodeResponse.java ===
package com.falcon.falcon.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data @NoArgsConstructor @AllArgsConstructor
public class VerificationCodeResponse {
    String requestId;
    String expiryDate;
}



=== File: src/main/java/com/falcon/falcon/dto/VerificationEntry.java ===
package com.falcon.falcon.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class VerificationEntry implements Serializable {
    private String requestId;
    private String email;
    private String verificationCode;
    private String expiryDate;
}

// objects of this class will be stored in memory caches that support serialization.


=== File: src/main/java/com/falcon/falcon/entity/Challenge.java ===
package com.falcon.falcon.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.Collection;

@Entity
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Challenge {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String flag;
    private String name;
    private String title;
    private String description;

    @ManyToOne
    @JoinColumn(name = "room_id")
    private Room room;

    @OneToMany(mappedBy = "challenge", fetch = FetchType.LAZY)
    private Collection<FlagSubmission> flagSubmissions = new ArrayList<>();

    @OneToMany(mappedBy = "challenge", fetch = FetchType.LAZY)
    private Collection<Hint> hints = new ArrayList<>();
}



=== File: src/main/java/com/falcon/falcon/entity/FlagSubmission.java ===
package com.falcon.falcon.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class FlagSubmission {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String submittedFlag;
    private Boolean isCorrect;
    private Date sumbissionDate;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToOne
    @JoinColumn(name = "challenge_id")
    private Challenge challenge;
}



=== File: src/main/java/com/falcon/falcon/entity/Hint.java ===
package com.falcon.falcon.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Hint {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String description;

    @ManyToOne
    @JoinColumn(name = "challenge_id")
    private Challenge challenge;
}



=== File: src/main/java/com/falcon/falcon/entity/Instance.java ===
package com.falcon.falcon.entity;
import com.falcon.falcon.enums.InstanceStateEnum;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Instance {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String ipAddress;
    private String instanceId;
    private Date launchDate;
    private Date expirationDate;
    private InstanceStateEnum instanceState;
    // private String AMIid;

    // Many instances are launched from one Room
    @ManyToOne // this field manages the relationship between room and instance
    @JoinColumn(name = "room_id")
    private Room room; // Each Instance holds a reference to one Room. what we usually do is , we create an instance, then we add it to a list of instance in a room then we save the room.

    // Many instances are launched by one User
    @ManyToOne // this field manages the relationship between user and instance
    @JoinColumn(name = "user_id")
    private User user;


    // these two references will be used by hibernate to persist changes.
    // typically this happens, let us say user 1 launched a new instance from room 1
    // we create new instance object we retrieve user 1 and room 1 we set them to instance then we persist it after doing this Hibernate will locate the references for room and user in instance and set the foreign keys
}



=== File: src/main/java/com/falcon/falcon/entity/Role.java ===
package com.falcon.falcon.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.Collection;

@Entity
@Data @NoArgsConstructor @AllArgsConstructor
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String name;

    // here we only reference where we configured the join table
    // so that JPA knows what join table to use to get users associated to a role.
    @ManyToMany(mappedBy = "roles")
    private Collection<User> users = new ArrayList<>();
}



=== File: src/main/java/com/falcon/falcon/entity/Room.java ===
package com.falcon.falcon.entity;
import com.falcon.falcon.enums.Complexity;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.Collection;

@Entity
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Room {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String amiId;
    private String title;
    private String description;
    @Enumerated(EnumType.STRING)
    @Column(name = "complexity")
    private Complexity complexity;
    private int totalChallenges;
    private String imageURL;
    private int estimatedTime;

    // these variables change over time
    private int totalRunningInstances; // whenever a new instance is launched we should go add a number here, when stopped or terminated we reduce a number from here.
    private int totalJoinedUsers; // when a user joins we add a number here when a user leaves a room we reduce a number.
    // the room will be an observer, it will observe the userService , when a user interacts with instances or joins or leave a room we notify the room service so we can change those variables

    @OneToMany(mappedBy = "room", fetch = FetchType.LAZY)
    private Collection<Instance> instances = new ArrayList<>();

    @OneToMany(mappedBy = "room", fetch = FetchType.LAZY)
    private Collection<Challenge> challenges = new ArrayList<>();

    // this is useful with cascade.all when a user joins a room, we will retrieve the user and the room then create a membership
    // now after creating the membership how do we persist all this in the database in order for the relationship to be there.
    // now the membership is transient so in order for the entry in the join table to be created we need, to set the room and user in membership and then persist it.
    @OneToMany(mappedBy = "room", fetch = FetchType.LAZY) // room references many memberships but Room doesn't own and manage the relationship
    private Collection<RoomMembership> memberships = new ArrayList<>();
}



=== File: src/main/java/com/falcon/falcon/entity/RoomMembership.java ===
package com.falcon.falcon.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class RoomMembership {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;


    private Boolean isJoined;
    private Boolean isSaved;
    private Boolean isCompleted;
    private Date completedAt;
    private int challengesCompleted;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id")
    private Room room;

}



=== File: src/main/java/com/falcon/falcon/entity/User.java ===
package com.falcon.falcon.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.Collection;

@Entity
@Data @NoArgsConstructor @AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String email;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @ManyToMany // owner side is where we configure the relationship.
    @JoinTable( // @JoinTable configures the Join table
            name = "users_roles", // gives a name to the join table
            joinColumns = @JoinColumn(name = "user_id"), // @JoinColumn configures the foreign Keys in the Join Table
            inverseJoinColumns = @JoinColumn(name = "role_id")
    ) // we use @JoinTable/@JoinColumn to manually configure the table and columns names.
    private Collection<Role> roles = new ArrayList<>();

    // cascade.ALL will help us manage RoomMemberships !!
    /*
    The concept is straightforward: we instantiate a Membership entity,
    configure its properties (e.g., user and room),
    add it to the User’s memberships collection, and then persist the User.
    This leverages the cascade = CascadeType.ALL annotation to automatically save the Membership to the database,
    ensuring the relationship is established efficiently.
    */
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Collection<RoomMembership> memberships = new ArrayList<>();

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Collection<FlagSubmission> flagSubmissions = new ArrayList<>();

    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    private Collection<Instance> instances = new ArrayList<>();
}



=== File: src/main/java/com/falcon/falcon/enums/Complexity.java ===
package com.falcon.falcon.enums;

public enum Complexity {
    EASY, MEDIUM, HARD
}



=== File: src/main/java/com/falcon/falcon/enums/InstanceStateEnum.java ===
package com.falcon.falcon.enums;

public enum InstanceStateEnum {
    NOT_STARTED,RUNNING,PAUSED, TERMINATED
}



=== File: src/main/java/com/falcon/falcon/exceptions/CodeExpiredException.java ===
package com.falcon.falcon.exceptions;

public class CodeExpiredException extends RuntimeException {
    public CodeExpiredException(String message) {
        super(message);
    }
}



=== File: src/main/java/com/falcon/falcon/exceptions/EmaiNotVerifiedOrRequestIdNotValid.java ===
package com.falcon.falcon.exceptions;

public class EmaiNotVerifiedOrRequestIdNotValid extends RuntimeException {
    public EmaiNotVerifiedOrRequestIdNotValid(String message) {
        super(message);
    }
}



=== File: src/main/java/com/falcon/falcon/exceptions/RoleNotFoundException.java ===
package com.falcon.falcon.exceptions;

public class RoleNotFoundException extends RuntimeException {
    public RoleNotFoundException(String message) {
        super(message);
    }
}



=== File: src/main/java/com/falcon/falcon/exceptions/RoomAlreadySavedException.java ===
package com.falcon.falcon.exceptions;

public class RoomAlreadySavedException extends RuntimeException {
    public RoomAlreadySavedException(String message) {
        super(message);
    }
}



=== File: src/main/java/com/falcon/falcon/exceptions/RoomMembershipNotFoundException.java ===
package com.falcon.falcon.exceptions;

public class RoomMembershipNotFoundException extends RuntimeException {
    public RoomMembershipNotFoundException(String message) {
        super(message);
    }
}



=== File: src/main/java/com/falcon/falcon/exceptions/RoomNotFoundException.java ===
package com.falcon.falcon.exceptions;

public class RoomNotFoundException extends RuntimeException {
    public RoomNotFoundException(String message) {
        super(message);
    }
}



=== File: src/main/java/com/falcon/falcon/exceptions/UserAlreadyExistsException.java ===
package com.falcon.falcon.exceptions;

public class UserAlreadyExistsException extends RuntimeException {
    public UserAlreadyExistsException(String message) {
        super(message);
    }
}



=== File: src/main/java/com/falcon/falcon/exceptions/UserAlreadyJoinedException.java ===
package com.falcon.falcon.exceptions;

public class UserAlreadyJoinedException extends RuntimeException {
    public UserAlreadyJoinedException(String message) {
        super(message);
    }
}



=== File: src/main/java/com/falcon/falcon/exceptions/UserNotFoundException.java ===
package com.falcon.falcon.exceptions;

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}



=== File: src/main/java/com/falcon/falcon/exceptions/VerificationCodeInvalid.java ===
package com.falcon.falcon.exceptions;

public class VerificationCodeInvalid extends RuntimeException {
    public VerificationCodeInvalid(String message) {
        super(message);
    }
}



=== File: src/main/java/com/falcon/falcon/facade/DomainFacade.java ===
package com.falcon.falcon.facadePattern;

import com.falcon.falcon.dto.RoomDTO;

import java.util.List;

// ready for tests !!
// To show personalized room cards, we need to create a facade method that combines room and user-specific data.
public interface DomainFacade {
    List<RoomDTO> getRoomCatalogForUser(Long userId);
}



=== File: src/main/java/com/falcon/falcon/facade/impl/DomainFacadeIml.java ===
package com.falcon.falcon.facadePattern.impl;

import com.falcon.falcon.dto.RoomDTO;
import com.falcon.falcon.facadePattern.DomainFacade;
import com.falcon.falcon.service.RoomService;
import com.falcon.falcon.service.UserRoomService;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/*
 * The aggregation layer is a design pattern that combines data and functionality from several sources or services into a single
 * higher-level API. In our project, the DomainFacade serves as the aggregation layer by orchestrating calls to RoomService,
 * UserService, and UserRoomService. This layer consolidates base room data and user-specific room details, ensuring that the
 * client receives all the necessary information in one response. It separates concerns by keeping lower-level services focused on
 * their specific tasks while the aggregation layer handles the integration and transformation of that data.
 */
// ready for tests !!
@Component
public class DomainFacadeIml implements DomainFacade {
    private final RoomService roomService;
    private final UserRoomService userRoomService;

    public DomainFacadeIml(RoomService roomService, UserRoomService userRoomService) {
        this.roomService = roomService;
        this.userRoomService = userRoomService;
    }

    // this method needs three things
      // - all rooms with no information about users
      // - joined rooms by a user, these rooms should contain information about the membership
      // - saved rooms

    // and it should return a list of rooms that contain information about the membership
      // - isJoined / joinedAt / isSaved / completedAt / percentageCompleted

    @Override
    @Transactional
    public List<RoomDTO> getRoomCatalogForUser(Long userId) {
        // step 1 : Get all base room information using roomManager/roomService this service provides us with information regarding rooms NOT USERS
        List<RoomDTO> allRooms = roomService.getAllRooms();
        // these rooms are not joined or saved by default and their achievement rate is by default 0 until we check the user's joined/saved rooms
        // step 2 : Get rooms user has joined or saved  using userManager/userService this service provides us with information regarding users NOT ROOMS (like for example rooms a user has joined !!!)
        List<RoomDTO> joinedRooms = userRoomService.getJoinedRooms(userId); // this method, retrieves a user and its memberships, for each membership it gets the room associated with that membership. it returns a list of roomDTOs
        List<RoomDTO> savedRooms = userRoomService.getSavedRooms(userId);

        // step 3 : Use streams
        return allRooms.stream() //
                .map(room -> enrichRoomWithUserData(room, joinedRooms, savedRooms))
                .collect(Collectors.toList());
    }

    private RoomDTO enrichRoomWithUserData(RoomDTO room, List<RoomDTO> joinedRooms, List<RoomDTO> savedRooms) {
        // we check if the room has joined by the user.
        joinedRooms.stream()
                .filter(joinedRoom -> joinedRoom.getId().equals(room.getId()))
                .findFirst() // terminal operation
                .ifPresent(joinedRoom -> { // if the
                    room.setIsJoined(joinedRoom.getIsJoined());
                    room.setIsSaved(joinedRoom.getIsSaved()); // this will set is saved to false if the user didnt save the room
                    room.setPercentageCompleted(joinedRoom.getPercentageCompleted());
                });

        // we check if the user has saved the room
        savedRooms.stream()
                .filter(r -> r.getId().equals(room.getId()))
                .findFirst()
                .ifPresent(savedRoom -> room.setIsSaved(true));

        return room;
    }
}


// Streams process sequences of data
// Streams are not data structures, they are a way to process data in a functional style
// data sources are mainly collections with finite elements.
// Streams are not stored in memory, they are computed on demand !
// To perform a sequence of operations over the elements of the data source and aggregate their results, we need three parts: the source, intermediate operation(s) and a terminal operation.
// in order to process sequences of data sourced from collections we define a pipeline of operations on a collection
// the pipeline is a sequence of operations that are applied to the elements of the collection
// Streams are Synchronous. When you invoke a terminal operation, the stream processes all data immediately and blocks until completion.
// We can only use one terminal operation per stream
// intermediate operations which reduce the size of the stream should be placed before operations which are applying to each element. So we need to keep methods such as skip(), filter(), and distinct() at the top of our stream pipeline.


=== File: src/main/java/com/falcon/falcon/FalconApplication.java ===
package com.falcon.falcon;

import io.github.cdimascio.dotenv.Dotenv;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class FalconApplication implements CommandLineRunner {
	private String myname;

	public FalconApplication(@Value("${myname}") String myname) {
		this.myname = myname;
	}

	public static void main(String[] args) {
		System.out.println("Falcon application started");
		System.out.println("Loading env variables");
		Dotenv dotenv = Dotenv.configure().load();
		dotenv.entries().forEach(entry -> System.setProperty(entry.getKey(), entry.getValue()));
		// Start Spring Boot application
		SpringApplication.run(FalconApplication.class, args);
	}

	@Override
	public void run(String... args) throws Exception {

		System.out.println(myname);

	}
}



=== File: src/main/java/com/falcon/falcon/mapper/ChallengeMapper.java ===
package com.falcon.falcon.mapper;

import com.falcon.falcon.dto.ChallengeDTO;
import com.falcon.falcon.entity.Challenge;
import org.springframework.stereotype.Component;

@Component
public class ChallengeMapper {

    public ChallengeDTO toChallengeDTO(Challenge challenge) {
        return ChallengeDTO.builder()
                .id(challenge.getId())
                .name(challenge.getName())
                .flag(null)
                .title(challenge.getTitle())
                .description(challenge.getDescription())
                .build();
    }

    public Challenge toChallenge(ChallengeDTO challengeDTO) {
        return Challenge.builder()
                .name(challengeDTO.getName())
                .title(challengeDTO.getTitle())
                .description(challengeDTO.getDescription())
                .flag(challengeDTO.getFlag())
                .build();
    }
}



=== File: src/main/java/com/falcon/falcon/mapper/RoomMapper.java ===
package com.falcon.falcon.mapper;

import com.falcon.falcon.dto.RoomDTO;
import com.falcon.falcon.entity.Room;
import com.falcon.falcon.entity.RoomMembership;
import org.springframework.stereotype.Component;

@Component
public class RoomMapper {

    public RoomDTO toUserSpecificDTO(Room room, RoomMembership roomMembership) {
        RoomDTO dto = toDTO(room);
        // Add null check and divide-by-zero protection
        if (roomMembership != null && room.getTotalChallenges() > 0) {
            dto.setPercentageCompleted((roomMembership.getChallengesCompleted() * 100) / room.getTotalChallenges());
        } else {
            dto.setPercentageCompleted(0); // Default to 0% if no challenges or no membership
        }
        dto.setIsJoined(roomMembership.getIsJoined());
        dto.setIsSaved(roomMembership.getIsSaved());
        return dto;
    }

    public RoomDTO toDTO(Room room) {
        return RoomDTO.builder()
                // over all information
                .id(room.getId())
                .amiId(room.getAmiId())
                .title(room.getTitle())
                .description(room.getDescription())
                .complexity(room.getComplexity())
                .estimatedTime(room.getEstimatedTime())
                .imageURL(room.getImageURL())
                .totalChallenges(room.getTotalChallenges())
                .totalJoinedUsers(room.getTotalJoinedUsers())
                .totalRunningInstances(room.getTotalRunningInstances())
                .isJoined(false) // this is set to false because we still dont know the user we are retrieveving the room for
                .isSaved(false) // same thing
                .percentageCompleted(0) // same thing
                .build();
    }

    // now if we are creating a new room we need a mapper that turns a DTO to an entity
    public Room toEntity(RoomDTO roomDTO) {
        return Room.builder()
                .amiId(roomDTO.getAmiId())
                .title(roomDTO.getTitle())
                .description(roomDTO.getDescription())
                .complexity(roomDTO.getComplexity())
                .estimatedTime(roomDTO.getEstimatedTime())
                .imageURL(roomDTO.getImageURL())
                .totalChallenges(roomDTO.getTotalChallenges())
                .totalJoinedUsers(0) // this is set to 0 because we are creating a new room
                .totalRunningInstances(0) // this is set to 0 because we are creating a new room
                .build();
    }

}



=== File: src/main/java/com/falcon/falcon/mapper/UserMapper.java ===
package com.falcon.falcon.mapper;

import com.falcon.falcon.dto.UserDTO;
import com.falcon.falcon.entity.User;
import lombok.AllArgsConstructor;
import lombok.Data;
import org.springframework.stereotype.Component;

@Component
@Data @AllArgsConstructor
public class UserMapper {

    // after retrieving entities we map them to DTOs
    public UserDTO toDTO(User user){
        UserDTO userDTO = new UserDTO();
        userDTO.setId(user.getId());
        userDTO.setUsername(user.getUsername());
        userDTO.setEmail(user.getEmail());
        userDTO.setRoles(user.getRoles());
        return userDTO;
    }

    // we map data access objects coming from the presentation layer to persisting Entities
    public User toEntity(UserDTO userDTO){
        User user = new User();
        user.setUsername(userDTO.getUsername());
        user.setEmail(userDTO.getEmail());
        return user;
    }
}



=== File: src/main/java/com/falcon/falcon/repository/ChallengeRepository.java ===
package com.falcon.falcon.repository;

import com.falcon.falcon.entity.Challenge;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ChallengeRepository extends JpaRepository<Challenge, Long> {
}



=== File: src/main/java/com/falcon/falcon/repository/FlagSubmissionRepository.java ===
package com.falcon.falcon.repository;

import com.falcon.falcon.entity.FlagSubmission;
import org.springframework.data.jpa.repository.JpaRepository;

public interface FlagSubmissionRepository extends JpaRepository<FlagSubmission, Long> {
}



=== File: src/main/java/com/falcon/falcon/repository/HintRepository.java ===
package com.falcon.falcon.repository;

import com.falcon.falcon.entity.Hint;
import org.springframework.data.jpa.repository.JpaRepository;

public interface HintRepository extends JpaRepository<Hint, Long> {
}



=== File: src/main/java/com/falcon/falcon/repository/InstanceRepository.java ===
package com.falcon.falcon.repository;

import com.falcon.falcon.entity.Instance;
import org.springframework.data.jpa.repository.JpaRepository;

public interface InstanceRepository extends JpaRepository<Instance, Long> {
}



=== File: src/main/java/com/falcon/falcon/repository/RoleRepository.java ===
package com.falcon.falcon.repository;

import com.falcon.falcon.entity.Role;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(String name);
}



=== File: src/main/java/com/falcon/falcon/repository/RoomMembershipRepository.java ===
package com.falcon.falcon.repository;

import com.falcon.falcon.entity.RoomMembership;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface RoomMembershipRepository extends JpaRepository<RoomMembership, Long> {
    Optional<RoomMembership> findByRoomIdAndUserId(Long roomId, Long userId);
}



=== File: src/main/java/com/falcon/falcon/repository/RoomRepository.java ===
package com.falcon.falcon.repository;

import com.falcon.falcon.entity.Room;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface RoomRepository extends JpaRepository<Room, Long> {
    @EntityGraph(attributePaths = {"challenges"})
    Optional<Room> findRoomWithChallengesById(Long id); // this fetches a room and all its challenges and returns an Optional with the room object with a list of fetched challenges
    boolean existsByAmiId(String amiId); // this checks if a room with the same amiId already exists
}



=== File: src/main/java/com/falcon/falcon/repository/UserRepository.java ===
package com.falcon.falcon.repository;

import com.falcon.falcon.entity.User;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    // we will use derived query method provided by Spring Data JPA
    // in this example we want to check if a user with a given email exists
    // the naming is not arbitrary, it must follow certain rules
    Optional<User> findByEmail(String email); // this returns an Optional that may or may not have a user
    Optional<User> findByUsername(String username);

    // Basic graph - loads only memberships
    @EntityGraph(attributePaths = {"memberships"})
    Optional<User> findUserWithBasicMembershipsById(Long id);

    @EntityGraph(attributePaths = {"memberships", "memberships.room"})
    Optional<User> findUserWithMembershipsAndRoomsById(Long id);

    @EntityGraph(attributePaths = {"memberships", "memberships.room", "memberships.room.challenges"})
    Optional<User> findUserWithMembershipsAndRoomsAndChallengesById(Long id); // this fetches a user and all its memberships and rooms and challenges
}



=== File: src/main/java/com/falcon/falcon/security/JwtConfig.java ===
package com.falcon.falcon.security;

import com.nimbusds.jose.jwk.JWK;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.ImmutableJWKSet;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.SecurityContext;
import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.Resource;
import org.springframework.security.oauth2.jwt.*;

import java.io.InputStreamReader;
import java.io.Reader;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;

// this class provide objects that encode and decode JWT tokens
// we inject RSA keys and parse them so they can be used to sign tokens by the encoder and to verify signatures by the decoder
@Configuration
public class JwtConfig {
    private final RSAPrivateKey privateKey;
    private final RSAPublicKey publicKey;

    // the public key bean is in a pem format so we need to convert it from pem to a java RSAPublicKey object
    // we need a PEM parser this parser does the following :
    // - reads the PEM file, which usually has extensions like .pem
    // - The content of a PEM file is encoded in base64 and enclosed between -----BEGIN and -----END headers (e.g., -----BEGIN CERTIFICATE----- and -----END CERTIFICATE-----). The parser decodes this base64 content into its binary form.
    // - The parser extracts the actual data, such as an X.509 certificate, an RSA private key, or other cryptographic objects, from the decoded binary.
    // the constructor loads both the private and public .pem files and convert them to characters then it parses them and stores them in our local properties
    public JwtConfig(@Value("${jwt.private.key}") Resource privateKeyResource,
                     @Value("${jwt.public.key}") Resource publicKeyResource) throws Exception {

        try (Reader privateKeyReader = new InputStreamReader(privateKeyResource.getInputStream());
             Reader publicKeyReader = new InputStreamReader(publicKeyResource.getInputStream())
        ) {
            JcaPEMKeyConverter converter = new JcaPEMKeyConverter();
            // Load private key
            PEMParser pemParser = new PEMParser(privateKeyReader);
            PrivateKeyInfo privateKeyInfo = (PrivateKeyInfo) pemParser.readObject();
            this.privateKey = (RSAPrivateKey) converter.getPrivateKey(privateKeyInfo);
            pemParser.close();
            // Load public key
            pemParser = new PEMParser(publicKeyReader);
            SubjectPublicKeyInfo publicKeyInfo = (SubjectPublicKeyInfo) pemParser.readObject();
            this.publicKey = (RSAPublicKey) converter.getPublicKey(publicKeyInfo);
        }
    }

    // this bean encodes a jwt using a public and private key.
    // this will be used when generating a jwt
    @Bean
    public JwtEncoder jwtEncoder() {
        JWK jwk = new RSAKey.Builder(this.publicKey)
                .privateKey(this.privateKey)
                .build();
        JWKSource<SecurityContext> jwkSource = new ImmutableJWKSet<>(new JWKSet(jwk));
        return new NimbusJwtEncoder(jwkSource);
    }

    // asymmetric algorithm
    // When using RSA keys for JWT validation, the decoder only needs the public key to verify if a token is valid.
    // we will use the public key we injected and parsed.
    @Bean
    public JwtDecoder jwtDecoder() {
        return NimbusJwtDecoder.withPublicKey(this.publicKey).build();
    }


}



=== File: src/main/java/com/falcon/falcon/security/SecurityConfig.java ===
package com.falcon.falcon.security;

import com.falcon.falcon.service.impl.CustomUserDetailsService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

// this class will provide a bean of a configured securityFilterChain, the filter chain is configured to validate the access-tokens for all the requests that require validation.
// we add a jwt validator to the filter chain.
// we aldo provide a decoder bean that uses the public key to verify if requests are valid. this bean is used by the OAuth2 resource server validator to check the validity of access-tokens
@Configuration
@EnableWebSecurity // this annotation triggers the configuration of Spring Security's web infrastructure and creates a security filter chain.
public class SecurityConfig {

    private final JwtDecoder jwtDecoder; // this will be used by the security filter chain to decode and validate access-token
    private final CustomUserDetailsService customUserDetailsService; // this will be used by teh authentication provider to load a user by username

    public SecurityConfig(JwtDecoder jwtDecoder, CustomUserDetailsService customUserDetailsService) {
        this.jwtDecoder = jwtDecoder;
        this.customUserDetailsService = customUserDetailsService;
    }

    // this method will return a bean that will be managed by the IoC
    // The SecurityFilterChain bean is used to configure the security filter chain for HTTP requests. (the filter chain is a middleware that validates http requests)
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http     // this configures spring security not to create server side sessions for Http requests (by default spring security creates sessions upon receiving Http requests)
                .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .csrf(AbstractHttpConfigurer::disable) // Stateless token based authentication do not require csrf tokens, because we don't authenticate using browser cookies, we retrieve a token from the local storage and put in the authorization header
                .cors(Customizer.withDefaults()) // requests can be made from different origins right now (our front end app)
                // we are not gonna manually create a token validator !
                // we will set up our application as an OAuth2 resource server that validates JWT tokens
                // an OAuth2 resource server is responsible for serving protected resources (API endpoints)
                // it validates the access-token included in the Authorization header of incoming requests.
                // we will use our own decoder, a jwt decoder is configured with a public key that we generated so that we can know if a jwt was signed by our app or not, now whenever a request comes, OAuth2 will take the jwt and then use the decoder
                // the Decoder will take the signature of the jwt, decrypt it using the public key -> get the original hash = hashed (Header + payload)
                // then it will hash the current Header and payload , and compare, if the decrypted signature is equal to the hashed header and payload then this token was signed using the correct private key
                .headers(headers -> headers.frameOptions(frameOptions -> frameOptions.disable()))
                .authorizeHttpRequests(ar -> {
                    ar.requestMatchers("/auth/**").permitAll();
                    ar.requestMatchers("/api/**").permitAll();
                    ar.anyRequest().authenticated();
                    System.out.println("Security configuration applied: /auth/** is permitted");
                })
                .oauth2ResourceServer(oauth2 -> oauth2.jwt(jwt -> jwt.decoder(jwtDecoder)));
        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(customUserDetailsService);
        provider.setPasswordEncoder(passwordEncoder()); // this will be used to hash the password and compare it with the hashed one.
        return new ProviderManager(provider);
    }






    // handling requests coming from browsers with CORS
    @Bean
    CorsConfigurationSource corsConfigurationSource() {
        /*Cross-Origin Resource Sharing (CORS) is a security
         feature that allows browser-based requests using AJAX.
         CORS helps keep web interactions secure while allowing
         necessary communication between different websites.*/
        CorsConfiguration corsConfiguration = new CorsConfiguration(); // a class provided by Spring that holds the CORS configuration settings
        // we will allow all origins to access our apis
        corsConfiguration.addAllowedOrigin("*");
        // This allows all HTTP methods (GET, POST, PUT, DELETE, etc.) from any origin to be executed.
        corsConfiguration.addAllowedMethod("*");
        // This allows any HTTP header to be included in the request from the client.
        corsConfiguration.addAllowedHeader("*");

        // corsConfiguration.setExposedHeaders(List.of("x-auth-token"));
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", corsConfiguration);
        return source;
    }



}



=== File: src/main/java/com/falcon/falcon/service/AuthService.java ===
package com.falcon.falcon.service;

import com.falcon.falcon.dto.authDto.SignUpRequest;
import com.falcon.falcon.dto.UserDTO;
import com.falcon.falcon.dto.authDto.VerificationCodeRequest;
import com.falcon.falcon.dto.authDto.VerificationCodeResponse;
import com.falcon.falcon.exceptions.userExceptions.UserAlreadyExistsException;
import org.springframework.security.core.Authentication;

import java.util.Map;

// the main entry point
// responsible for orchestrating the flows between more specialized services.
// the AuthController will only inject the AuthService
// it will only call methods in AuthService
// then AuthService will orchestrate calls to specialized services
public interface AuthService {
    // AuthService will have methods that delegate work to other services
      // requestVerificationCode ----(Check email)----> UserService
      // requestVerificationCode ----(generate verification request)----> VerificationService
      // requestVerificationCode ----(store verification request in Redis)----> VerificationService
    VerificationCodeResponse requestVerificationCode(VerificationCodeRequest request) throws UserAlreadyExistsException;
      // completeRegistration ----(Validate code)----> VerificationService
      // completeRegistration ----(create user)----> UserService
      // completeRegistration ----(generate jwt)----> jwt service
    UserDTO completeRegistration(SignUpRequest request);

    Map<String, String> generateAccessToken(Authentication result);
}



=== File: src/main/java/com/falcon/falcon/service/EmailService.java ===
package com.falcon.falcon.service;

public interface EmailService {
    public void emailCode(String code, String expiryDate, String toEmail);
}



=== File: src/main/java/com/falcon/falcon/service/impl/AuthServiceImp.java ===
package com.falcon.falcon.service.impl;

import com.falcon.falcon.dto.*;
import com.falcon.falcon.exceptions.userExceptions.UserAlreadyExistsException;
import com.falcon.falcon.service.*;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
public class AuthServiceImp implements AuthService {
    private UserService userService;
    private EmailService emailService;
    private VerificationService verificationService;
    private TokenService tokenService;

    public AuthServiceImp(UserService userService, EmailService emailService, VerificationService verificationService, TokenService tokenService) {
        this.userService = userService;
        this.emailService = emailService;
        this.verificationService = verificationService;
        this.tokenService = tokenService;
    }
    // this method will be used to check if the email to verify isnt taken.
    // then it generates a request ID a verification code and stores everything in Redis
    // then it sends an email with the code
    @Override
    public VerificationCodeResponse requestVerificationCode(VerificationCodeRequest request) throws UserAlreadyExistsException {
        // Validate email doesn't exist
        this.userService.validateEmailNotExists(request.getEmail());
        // Generate verification entry
        VerificationEntry entry = this.verificationService.generateVerificationEntry(request.getEmail());
        // Store in Redis
        this.verificationService.storeRequest(entry);
        this.emailService.emailCode(
                entry.getVerificationCode(),
                entry.getExpiryDate(),
                request.getEmail()
        );
        return new VerificationCodeResponse(entry.getRequestId(), entry.getExpiryDate());
    }

    @Override
    public UserDTO completeRegistration(SignUpRequest request) {
        // Validate the verification code
        verificationService.validateVerificationCodeAgainstRedis(request); // this generates exceptions related to
        // Create the user
        UserDTO userDTO = new UserDTO();
        userDTO.setEmail(request.getEmail());
        userDTO.setUsername(request.getUsername());
        userDTO.setPassword(request.getPassword());

        // Save the user (this now includes roles in the UserDTO)
        UserDTO createdUser = userService.createUser(userDTO); // this should generate exceptions related to user creation
        return createdUser;
    }

    @Override
    public Map<String, String> generateAccessToken(Authentication authentication) {
        return this.tokenService.generateToken(authentication.getName(), authentication.getAuthorities());
    }
}



=== File: src/main/java/com/falcon/falcon/service/impl/CustomUserDetailsService.java ===
package com.falcon.falcon.service.impl;

import com.falcon.falcon.entity.User;
import com.falcon.falcon.repository.UserRepository;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.stream.Collectors;

@Service // this bean is used by the authentication provider to load the user by username and compare credentials
public class CustomUserDetailsService implements UserDetailsService {
    private final UserRepository userRepository;

    public CustomUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username).orElseThrow(()->new UsernameNotFoundException("User not found: " + username)); // we get the user by Username
        Collection<GrantedAuthority> grantedAuthorities = user.getRoles().stream().map(role -> new SimpleGrantedAuthority(role.getName())).collect(Collectors.toSet()); // we extract roles
        UserDetails userDetails = org.springframework.security.core.userdetails.User // pattern Builder : we build the User Details Object and return it
                .withUsername(user.getUsername())
                .password(user.getPassword())
                .authorities(grantedAuthorities)
                .build();
        return userDetails;
    }
}



=== File: src/main/java/com/falcon/falcon/service/impl/EmailServiceImp.java ===
package com.falcon.falcon.service.impl;

import com.falcon.falcon.service.EmailService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Service
public class EmailServiceImp implements EmailService {

    private final JavaMailSender mailSender;
    private final String fromEmail;

    public EmailServiceImp(JavaMailSender mailSender,
                        @Value("${spring.mail.username}") String fromEmail) {
        this.mailSender = mailSender;
        this.fromEmail = fromEmail;
    }

    public void emailCode(String code, String expiryDate, String toEmail) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom(fromEmail);
        message.setTo(toEmail);
        message.setSubject("Your Verification Code");
        message.setText("Your verification code is: " + code + "\n" +
                "This code will expire at: " + expiryDate);

        mailSender.send(message);
    }
}


=== File: src/main/java/com/falcon/falcon/service/impl/RoomServiceImpl.java ===
package com.falcon.falcon.service.impl;

import com.falcon.falcon.dto.RoomDTO;
import com.falcon.falcon.entity.Room;
import com.falcon.falcon.exceptions.roomExceptions.RoomAlreadySavedException;
import com.falcon.falcon.exceptions.roomExceptions.RoomNotFoundException;
import com.falcon.falcon.mapper.ChallengeMapper;
import com.falcon.falcon.mapper.RoomMapper;
import com.falcon.falcon.repository.RoomRepository;
import com.falcon.falcon.service.RoomService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class RoomServiceImpl implements RoomService {

    private RoomRepository roomRepository;
    private RoomMapper roomMapper;
    private ChallengeMapper challengeMapper;

    public RoomServiceImpl(RoomRepository roomRepository, RoomMapper roomMapper, ChallengeMapper challengeMapper) {
        this.roomRepository = roomRepository;
        this.roomMapper = roomMapper;
        this.challengeMapper = challengeMapper;
    }
//     @Transactional(readOnly = true) tells Spring and Hibernate, “This method will only read data from the database, not change it.”
    @Override
    @Transactional(readOnly = true)
    public List<RoomDTO> getAllRooms() {
        return roomRepository.findAll().stream()
                .map(room -> roomMapper.toDTO(room))
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public RoomDTO getRoomById(Long id) {
        Room room = roomRepository.findById(id).orElseThrow(()->new RoomNotFoundException("room not found"));
        RoomDTO roomDTO = roomMapper.toDTO(room);
        roomDTO.setChallenges(room.getChallenges().stream()
                .map(challenge -> challengeMapper.toChallengeDTO(challenge))
                .collect(Collectors.toList()));
        return roomDTO;
    }

    @Override
    @Transactional
    public RoomDTO createRoom(RoomDTO roomDTO) throws RoomAlreadySavedException {
        // Add debug logging
        System.out.println("Received RoomDTO: " + roomDTO);
        if (roomDTO.getAmiId() == null || roomDTO.getAmiId().trim().isEmpty()) {
            throw new IllegalArgumentException("amiId cannot be null or empty");
        }
        // we check if a room with the same AMI id already exists
        if(roomRepository.existsByAmiId(roomDTO.getAmiId())) {
            throw new RoomAlreadySavedException("Room with the same AMI id or task definition name already exists");
        }

        Room room = roomMapper.toEntity(roomDTO);
        System.out.println("Converted to Room entity: " + room);
        // else we create a new Room object from the DTO passed
        Room savedRoom = roomRepository.save(room);
        System.out.println("Saved Room: " + savedRoom);
        return roomMapper.toDTO(savedRoom);
    }
}

// NOTE 1 :
// a room has only one unique pair of AMIid and taskDefinitionName , these are used to identify the virtual machine or container image in the cloud
// each room has only type of machine, thus only AMI id if using EC2 instances or only one task definition name if using ECS containers
// we need to check if a room with the same AMIid or task definition already exists.


=== File: src/main/java/com/falcon/falcon/service/impl/TokenServiceImp.java ===
package com.falcon.falcon.service.impl;

import com.falcon.falcon.service.TokenService;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.jwt.JwtClaimsSet;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.JwtEncoderParameters;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.time.temporal.ChronoUnit;

import java.util.Collection;
import java.util.Map;
import java.util.stream.Collectors;

@Service
public class TokenServiceImp implements TokenService {
    private JwtEncoder jwtEncoder;

    public TokenServiceImp(JwtEncoder jwtEncoder) {
        this.jwtEncoder = jwtEncoder;
    }

    @Override
    public Map<String, String> generateToken(String subject, Collection<? extends GrantedAuthority> authorities){
        String scope = authorities.stream().map(GrantedAuthority::getAuthority).collect(Collectors.joining(" "));

        JwtClaimsSet claims = JwtClaimsSet.builder()
                .issuer("self") // we issued this token
                .issuedAt(Instant.now())
                .expiresAt(Instant.now().plus(30, ChronoUnit.MINUTES))
                .subject(subject)
                .claim("scope", scope)
                .build();

        String jwt = jwtEncoder.encode(JwtEncoderParameters.from(claims)).getTokenValue();
        return Map.of("access-token", jwt);
    }
}



=== File: src/main/java/com/falcon/falcon/service/impl/UserRoomServiceImp.java ===
package com.falcon.falcon.service.impl;

import com.falcon.falcon.dto.RoomDTO;
import com.falcon.falcon.entity.Room;
import com.falcon.falcon.entity.RoomMembership;
import com.falcon.falcon.entity.User;
import com.falcon.falcon.exceptions.roomExceptions.RoomNotFoundException;
import com.falcon.falcon.exceptions.userExceptions.UserNotFoundException;
import com.falcon.falcon.mapper.ChallengeMapper;
import com.falcon.falcon.mapper.RoomMapper;
import com.falcon.falcon.mapper.UserMapper;
import com.falcon.falcon.repository.RoleRepository;
import com.falcon.falcon.repository.RoomMembershipRepository;
import com.falcon.falcon.repository.RoomRepository;
import com.falcon.falcon.repository.UserRepository;
import com.falcon.falcon.service.UserRoomService;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
/**
 * Service responsible for managing user-room relationships and interactions.
 * Handles operations such as joining/saving rooms, retrieving user-specific room lists,
 * and managing room memberships. This service acts as an intermediary layer between
 * users and rooms, maintaining the state of user progress and preferences within rooms
 * through the RoomMembership entity. All operations are user-context aware, providing
 * personalized room data based on the user's interaction history.
 */
@Service
public class UserRoomServiceImp implements UserRoomService {
    private final ChallengeMapper challengeMapper;
    private RoomMapper roomMapper;
    private UserRepository userRepository;
    private RoomRepository roomRepository;
    private RoomMembershipRepository roomMembershipRepository;

    public UserRoomServiceImp(UserRepository userRepository, RoomRepository roomRepository, RoomMembershipRepository roomMembershipRepository, RoleRepository roleRepository, PasswordEncoder bCryptPasswordEncoder, UserMapper userMapper, RoomMapper roomMapper, ChallengeMapper challengeMapper) {
        this.userRepository = userRepository;
        this.roomRepository = roomRepository;
        this.roomMembershipRepository = roomMembershipRepository;
        this.challengeMapper = challengeMapper;
        this.roomMapper = roomMapper;
    }

    // getJoinedRooms(Long userId)
    /*
    Retrieves all rooms that a user has explicitly joined
 * 1. Fetches the user with their memberships and rooms using a custom repository query
 * 2. Filters memberships where isJoined = true
 * 3. Maps each membership to a RoomDTO with user-specific data (progress, status)
 * 4. Returns the list of rooms with their associated user membership data
 * Throws UserNotFoundException if user doesn't exist
     */
    @Override
    @Transactional(readOnly = true)
    public List<RoomDTO> getJoinedRooms(Long userId) throws UserNotFoundException {
        // first we retrieve the user (here we will use a custom query to get the user with its memberships and rooms) to avoid the static nature of EAGER and LAZY loading
        User user = this.userRepository.findUserWithMembershipsAndRoomsById(userId).orElseThrow(()->new UserNotFoundException("user not found"));
        // now we need to return all rooms joined by this user
        return user.getMemberships().stream()
                .filter(rm -> rm.getIsJoined().equals(true))
                .map(rm -> roomMapper.toUserSpecificDTO(rm.getRoom(), rm))
                .collect(Collectors.toList());
    }

    // getSavedRooms(Long userId):
    /*
     * Retrieves all rooms that a user has bookmarked/saved.
     * 1. Fetches the user with their memberships and rooms
     * 2. Filters memberships where isSaved = true
     * 3. Maps each membership to a RoomDTO with user-specific data
     * 4. Returns the list of saved rooms with their membership status
     * Throws UserNotFoundException if user doesn't exist
     */
    @Override
    @Transactional(readOnly = true)
    public List<RoomDTO> getSavedRooms(Long userId) throws UserNotFoundException {
        User user = this.userRepository.findUserWithMembershipsAndRoomsById(userId).orElseThrow(()->new UserNotFoundException("user not found"));
        return user.getMemberships().stream()
                .filter(rm -> rm.getIsSaved().equals(true))
                .map(rm -> roomMapper.toUserSpecificDTO(rm.getRoom(), rm))
                .collect(Collectors.toList());
    }

    // getCompletedRooms(Long userId):
    /*
     * Retrieves all rooms that a user has fully completed.
     * 1. Fetches user with memberships and rooms
     * 2. Filters memberships where completion rate = 100%
     * 3. Maps each membership to a RoomDTO with completion data
     * 4. Returns list of completed rooms with their stats
     * Throws UserNotFoundException if user doesn't exist
     */
    @Override
    @Transactional(readOnly = true)
    public List<RoomDTO> getCompletedRooms(Long userId) throws UserNotFoundException {
        User user = this.userRepository.findUserWithMembershipsAndRoomsById(userId).orElseThrow(()->new UserNotFoundException("user not found"));
        return user.getMemberships().stream()
                .filter(m -> m.getChallengesCompleted()/m.getRoom().getTotalChallenges() == 1)
                .map(m -> roomMapper.toUserSpecificDTO(m.getRoom(), m))
                .collect(Collectors.toList());
    }

    // getJoinedRoom(Long userId, Long roomId):
    /*
     * Retrieves detailed information about a specific room the user has joined.
     * 1. Fetches user with memberships, rooms, and challenges
     * 2. Finds the specific room membership
     * 3. Maps room to RoomDTO including:
     *    - Room details (title, description)
     *    - Challenge list
     *    - Completion status
     * 4. Returns detailed room info with user-specific data
     * Throws UserNotFoundException if user not found
     * Throws RoomNotFoundException if room not found in user's memberships
     */
    @Override
    @Transactional(readOnly = true)
    public RoomDTO getJoinedRoom(Long userId, Long roomId) throws UserNotFoundException, RoomNotFoundException {
        // here we will fetch The User, and then we will search for the room in the memberships
        User user = this.userRepository.findUserWithMembershipsAndRoomsAndChallengesById(userId).orElseThrow(()->new UserNotFoundException("user not found"));
        // now we will search for the room in the memberships
        return user.getMemberships().stream()
                .filter(rm -> rm.getRoom().getId().equals(roomId))
                .map(rm -> {
                    Room room = rm.getRoom();
                    RoomDTO roomDTO = roomMapper.toDTO(room);
                    roomDTO.setChallenges(room.getChallenges().stream()
                            .map(challenge -> challengeMapper.toChallengeDTO(challenge))
                            .collect(Collectors.toList()));
                    return roomDTO;
                })
                .findFirst()
                .orElseThrow(()->new RoomNotFoundException("room not found")); // this unwraps the Optional and throws the exception if not found
    }

    @Override
    @Transactional
    public void joinRoom(Long userId, Long roomId) throws UserNotFoundException, RoomNotFoundException {
        // step 1 : this returns an optional (this may or may not have a roomMembership)
        Optional<RoomMembership> roomMembership = this.roomMembershipRepository.findByRoomIdAndUserId(roomId, userId);
        // step 2 : check
        roomMembership.ifPresentOrElse(
                // if the room membership is present
                membership -> {
                    membership.setIsJoined(true); // we set isJoined to true
                    this.roomMembershipRepository.save(membership); // we persist it
                },
                // if the room membership is not present this means the room was never saved before, and an entry in the roomMembership table is not there
                () -> {
                    User user = this.userRepository.findById(userId).orElseThrow(() -> new UserNotFoundException("user not found")); // we first retrieve the user
                    Room room = this.roomRepository.findById(roomId).orElseThrow(() -> new RoomNotFoundException("room not found")); // then the room
                    RoomMembership newRoomMembership = new RoomMembership(); // then we create a new Room Membership
                    // we then set the relationship
                    newRoomMembership.setRoom(room);
                    newRoomMembership.setUser(user);
                    // then we mark the user as joined
                    newRoomMembership.setIsSaved(false);
                    newRoomMembership.setIsJoined(true);
                    this.roomMembershipRepository.save(newRoomMembership); // then we save the room membership
                    // in the future we should from here signal out to the roomService that a new user has joined a room
                }
        );

    }

    @Override
    @Transactional
    public void saveRoom(Long userId, Long roomId) throws UserNotFoundException, RoomNotFoundException {
        // again here we have two cases
        // if the user has joined the room then we will just modify the existing relationship
        // else we will create a new roomMembership

        // step 1
        Optional<RoomMembership> roomMembership = this.roomMembershipRepository.findByRoomIdAndUserId(roomId, userId);
        // step 2
        roomMembership.ifPresentOrElse(
                membership -> {
                    membership.setIsSaved(true);
                    this.roomMembershipRepository.save(membership);
                },
                // if the room membership is not present this means that there is no entry in the roomMembership table
                () -> {
                    User user = this.userRepository.findById(userId).orElseThrow(() -> new UserNotFoundException("user not found")); // we first retrieve the user
                    Room room = this.roomRepository.findById(roomId).orElseThrow(() -> new RoomNotFoundException("room not found")); // then the room
                    RoomMembership newRoomMembership = new RoomMembership(); // then we create a new Room Membership
                    // we then set the relationship
                    newRoomMembership.setRoom(room);
                    newRoomMembership.setUser(user);
                    // then we mark the user as joined
                    newRoomMembership.setIsJoined(false);
                    newRoomMembership.setIsSaved(true);
                    this.roomMembershipRepository.save(newRoomMembership); // then we save the room membership
                    // in the future we should from here signal out to the roomService that a new user has joined a room
                }
        );

    }
}



=== File: src/main/java/com/falcon/falcon/service/impl/UserServiceImp.java ===
package com.falcon.falcon.service.impl;

import com.falcon.falcon.dto.RoomDTO;
import com.falcon.falcon.dto.UserDTO;
import com.falcon.falcon.entity.Room;
import com.falcon.falcon.entity.RoomMembership;
import com.falcon.falcon.exceptions.*;
import com.falcon.falcon.mapper.ChallengeMapper;
import com.falcon.falcon.mapper.RoomMapper;
import com.falcon.falcon.mapper.UserMapper;
import com.falcon.falcon.entity.Role;
import com.falcon.falcon.entity.User;
import com.falcon.falcon.repository.RoleRepository;
import com.falcon.falcon.repository.RoomMembershipRepository;
import com.falcon.falcon.repository.RoomRepository;
import com.falcon.falcon.repository.UserRepository;
import com.falcon.falcon.service.UserService;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class UserServiceImp implements UserService {

    private UserRepository userRepository;
    private RoleRepository roleRepository;
    private PasswordEncoder bCryptPasswordEncoder;
    private UserMapper userMapper;

    public UserServiceImp(UserRepository userRepository, RoomRepository roomRepository, RoomMembershipRepository roomMembershipRepository, RoleRepository roleRepository, PasswordEncoder bCryptPasswordEncoder, UserMapper userMapper, RoomMapper roomMapper, ChallengeMapper challengeMapper) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.bCryptPasswordEncoder = bCryptPasswordEncoder;
        this.userMapper = userMapper;
    }

    public void validateEmailNotExists(String email) throws UserAlreadyExistsException {
        this.userRepository.findByEmail(email).ifPresent(u -> {
            throw new UserAlreadyExistsException("An account with this email already exists");
        });
    }

    // set for review !!
    @Override
    public UserDTO createUser(UserDTO userDTO) throws RoleNotFoundException {
        User newUser = this.userMapper.toEntity(userDTO);
        newUser.setPassword(this.bCryptPasswordEncoder.encode(userDTO.getPassword()));
        Role role = roleRepository.findByName("ROLE_USER").orElseThrow(() -> { throw new RoleNotFoundException("role not found"); });
        // now we will add the role to the collection of roles in the user and viceversa
        newUser.getRoles().add(role);
        role.getUsers().add(newUser);
        User savedUser = this.userRepository.save(newUser);
        roleRepository.save(role);
         // here we save the user.
        return userMapper.toDTO(savedUser);
    }


}



=== File: src/main/java/com/falcon/falcon/service/impl/VerificationServiceImp.java ===
package com.falcon.falcon.service.impl;

import com.falcon.falcon.dto.authDto.SignUpRequest;
import com.falcon.falcon.dto.authDto.VerificationEntry;
import com.falcon.falcon.exceptions.authExceptions.CodeExpiredException;
import com.falcon.falcon.exceptions.authExceptions.EmaiNotVerifiedOrRequestIdNotValid;
import com.falcon.falcon.exceptions.authExceptions.VerificationCodeInvalid;
import com.falcon.falcon.service.VerificationService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

@Service
public class VerificationServiceImp implements VerificationService {
    // acts as a bridge between your Java application and the Redis database
    private final RedisTemplate<String, Object> redisTemplate;
    private final int codeExpiryMinutes; // the number of minutes for the code validity
    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    // here we will inject the env variable dependency, environment variables declared in the properties file, are beans manages by the IoC
    // we can inject them into other IoC managed beans
    public VerificationServiceImp(@Value("${verification.code.expiry:10}") int codeExpiryMinutes, RedisTemplate<String, Object> redisTemplate){
        this.redisTemplate = redisTemplate;
        this.codeExpiryMinutes = codeExpiryMinutes;
    }

    @Override
    public VerificationEntry generateVerificationEntry(String email) {
        // Check if an active verification entry already exists for this email
        String existingRequestId = (String) redisTemplate.opsForValue().get("verification:email:" + email);

        if (existingRequestId != null) {
            // Retrieve the existing entry
            VerificationEntry existingEntry = (VerificationEntry) redisTemplate.opsForValue().get("verification:" + existingRequestId);
            if (existingEntry != null) {
                // Return the existing entry instead of creating a new one
                return existingEntry;
            }
            // If we get here, the entry exists in the email index but not in the main storage
            // This indicates a data consistency issue, so we'll remove the stale reference
            redisTemplate.delete("verification:email:" + email);
        }

        // Create a new entry if no active one exists
        String requestId = UUID.randomUUID().toString();
        String verificationCode = generateRandomCode();
        // here we will create a string that will represent the date and time when the code will be expired
        LocalDateTime expiryDateTime = LocalDateTime.now().plusMinutes(codeExpiryMinutes);
        String expiryDateStr = expiryDateTime.format(FORMATTER);
        return new VerificationEntry(requestId, email, verificationCode, expiryDateStr);
    }

    public void validateVerificationCodeAgainstRedis(SignUpRequest signUpRequest) throws CodeExpiredException, VerificationCodeInvalid, EmaiNotVerifiedOrRequestIdNotValid   {
       // we need to retrieve an entry from redis using the requestId
        // and check if the entry exists
        VerificationEntry storedVerificationEntry = (VerificationEntry) this.redisTemplate.opsForValue().get("verification:" + signUpRequest.getRequestId());
        if (storedVerificationEntry != null) {
            // now after that we checked that the requestId is for a non expired code
            // we will check if the email used in the SignUp request is the same one that received the Code
            String storedRequestId = (String) this.redisTemplate.opsForValue().get("verification:email:" + signUpRequest.getEmail());
            if ((storedRequestId != null) && (storedRequestId.equals(storedVerificationEntry.getRequestId()))) {
                // this means that the email used to sign up is present and the request corresponds
                // now we will check if the verification code is the same as the one stored in the verification entr
                if (signUpRequest.getCode().equals(storedVerificationEntry.getVerificationCode())) { // here we will check if the code sent is true !
                } else {
                    // here we generate a wrong code error
                    throw new VerificationCodeInvalid("invalid verification code");
                }
            } else {
                // this means either the email used to complete registration was never verified
                // or the requestId generated with this email is not the same as the one you sent
                throw new EmaiNotVerifiedOrRequestIdNotValid("Email used for sign up not verified or the request id doesn't correspond to the email");
            }

        } else {
            throw new CodeExpiredException("Code expired or wrong Request id");
        }

    }
    // this will write entries to Redis
    // we use the requestId as key
    public void storeRequest(VerificationEntry entry) {
        /* We will use the RedisTemplate instance template opsForValue() method to get an instance of ValueOperations,
        which provides methods to execute operations performed on simple values (or Strings in Redis terminology).
        The Redis SET method is implemented using the (you guessed it!) set() method, which takes a key name and a value. */
        /* the set method can take up to 4 arguments :
        *    1 - the key which will be used to retrieve values from Redis
        *    2 - the value object, what ae are storing
        *    3 - timeout 4 - time unit
        * */
        // Store using requestId as key for later verification
        redisTemplate.opsForValue().set(
                "verification:" + entry.getRequestId(),
                entry,
                codeExpiryMinutes,
                TimeUnit.MINUTES
        );

        // Also store using email to prevent multiple requests
        // this will be useful , in case a user already sent a verificationCodeRequest before, in this case well return back the already sent requestId
        // user 1 sent code request -> requesId and code generated all good, if the user goes to email and gets code and signs up then good, but if he resent a code request then we should only check if an entry is here is its here then we return a message prompying the user to check email
        redisTemplate.opsForValue().set(
                "verification:email:" + entry.getEmail(),
                entry.getRequestId(),
                codeExpiryMinutes,
                TimeUnit.MINUTES
        );


    }

    private String generateRandomCode() {
        // Generate a 6-digit verification code
        return String.format("%06d", (int)(Math.random() * 1000000));
    }
}


/*
• How to configure the connection to Redis from the application ?
• How to access and configure the Spring Data RedisTemplate ?
• How to use opsForXXX to read and write data to Redis ?

Spring Data Redis provides access to Redis from Spring applications.
It offers both low-level and high-level abstractions for interacting with Redis.
*/


=== File: src/main/java/com/falcon/falcon/service/InstanceService.java ===
package com.falcon.falcon.service;

public interface InstanceService {
}



=== File: src/main/java/com/falcon/falcon/service/RoomService.java ===
package com.falcon.falcon.service;

import com.falcon.falcon.dto.ChallengeDTO;
import com.falcon.falcon.dto.InstanceDTO;
import com.falcon.falcon.dto.RoomDTO;
import com.falcon.falcon.dto.UserDTO;
import com.falcon.falcon.exceptions.roomExceptions.RoomAlreadySavedException;
import com.falcon.falcon.exceptions.roomExceptions.RoomNotFoundException;

import java.util.List;

// provides basic room information
public interface RoomService {

    // Done ! ready for tests !!
    List<RoomDTO> getAllRooms();
    RoomDTO getRoomById(Long id) throws RoomNotFoundException;
    RoomDTO createRoom(RoomDTO roomDTO) throws RoomAlreadySavedException;

    /*
    RoomDTO updateRoom(Long id, RoomDTO roomDTO) throws RoomNotFoundException;

    List<UserDTO> getUsersInRoom(Long roomId) throws RoomNotFoundException;
    int getTotalUsersInRoom(Long roomId) throws RoomNotFoundException;

    List<InstanceDTO> getRunningInstancesInRoom(Long roomId) throws RoomNotFoundException;
    int getTotalRunningInstancesInRoom(Long roomId) throws RoomNotFoundException;

    List<ChallengeDTO> getChallengesInRoom(Long roomId) throws RoomNotFoundException;
    int getTotalChallengesInRoom(Long roomId) throws RoomNotFoundException;
*/
}

/*
*
The service provides the following domain operations:
Room Management:
Get a list of all rooms.
Retrieve details of a specific room by its ID (throws an exception if not found).
Create a new room (with checks against rooms already saved).
Update an existing room.
User Operations in a Room:
Retrieve the list of users present in a room.
Get the total number of users in a room.
Instance Operations in a Room:
Retrieve the list of all instances in a room.
Get the total count of all instances.
Retrieve the list of running instances.
Get the total count of running instances.
Challenge Operations in a Room:
Retrieve the list of challenges associated with a room.
Get the total number of challenges in a room.
Each of these operations focuses on specific aspects of the Room domain, clearly delineating boundaries for room, user, instance, and challenge management.
* */


=== File: src/main/java/com/falcon/falcon/service/TokenService.java ===
package com.falcon.falcon.service;

import org.springframework.security.core.GrantedAuthority;

import java.util.Collection;
import java.util.Map;

public interface TokenService {
    Map<String, String> generateToken(String subject, Collection<? extends GrantedAuthority> roles);
}



=== File: src/main/java/com/falcon/falcon/service/UserRoomService.java ===
package com.falcon.falcon.service;

import com.falcon.falcon.dto.RoomDTO;
import com.falcon.falcon.exceptions.roomExceptions.RoomNotFoundException;
import com.falcon.falcon.exceptions.userExceptions.UserNotFoundException;

import java.util.List;

public interface UserRoomService {
    // Room membership operations
    void joinRoom(Long userId, Long roomId) throws UserNotFoundException, RoomNotFoundException; // if the room is already saved we will set joinedAt to the existing room membership
    void saveRoom(Long userId, Long roomId) throws UserNotFoundException, RoomNotFoundException; // if the room is already joined we will set isSaved to true and not create the membership.
    // Room retrieval operations
    List<RoomDTO> getJoinedRooms(Long userId) throws UserNotFoundException; // we use the memberships
    List<RoomDTO> getSavedRooms(Long userId) throws UserNotFoundException; // we use the memberships
    List<RoomDTO> getCompletedRooms(Long userId) throws UserNotFoundException; // this requires knowing if a room is completed or not
    RoomDTO getJoinedRoom(Long userId, Long roomId) throws UserNotFoundException, RoomNotFoundException; // we use the memberships
}



=== File: src/main/java/com/falcon/falcon/service/UserService.java ===
package com.falcon.falcon.service;

import com.falcon.falcon.dto.RoomDTO;
import com.falcon.falcon.dto.UserDTO;
import com.falcon.falcon.entity.Room;
import com.falcon.falcon.exceptions.roomExceptions.RoomNotFoundException;
import com.falcon.falcon.exceptions.userExceptions.UserAlreadyExistsException;
import com.falcon.falcon.exceptions.userExceptions.UserNotFoundException;

import java.util.List;

// tracks user's relationship with rooms via memberships
public interface UserService {
    void validateEmailNotExists(String email) throws UserAlreadyExistsException;
    UserDTO createUser(UserDTO user) throws UserAlreadyExistsException;

   /* void leaveRoom(Long userId, Long roomId) throws UserNotFoundException, RoomNotFoundException; // if the room is saved we will only reset the progress and unjoin the user
    void unsaveRoom(Long userId, Long roomId) throws UserNotFoundException, RoomNotFoundException; // if the room is saved and joined we will un save it, if its saved and unjoined we will delete the room membership
  */
}

/**
 * This service handles user-related operations, including membership management.
 *
 * The joinRoom method is placed here because:
 * 1. The User entity is configured with cascade=CascadeType.ALL on its memberships collection,
 *    meaning it's responsible for persisting RoomMembership entities
 * 2. From a domain perspective, users initiate the action of joining rooms
 * 3. Transaction boundaries are cleaner when a single service manages the entire operation
 *
 * By following these principles, we maintain a clear separation of concerns where
 * UserService manages user-driven actions and the lifecycle of entities owned by User.
 */


=== File: src/main/java/com/falcon/falcon/service/VerificationService.java ===
package com.falcon.falcon.service;

import com.falcon.falcon.dto.authDto.SignUpRequest;
import com.falcon.falcon.dto.authDto.VerificationEntry;
import com.falcon.falcon.exceptions.authExceptions.CodeExpiredException;
import com.falcon.falcon.exceptions.authExceptions.EmaiNotVerifiedOrRequestIdNotValid;
import com.falcon.falcon.exceptions.authExceptions.VerificationCodeInvalid;

public interface VerificationService {
    VerificationEntry generateVerificationEntry(String email);
    void storeRequest(VerificationEntry entry);
    void validateVerificationCodeAgainstRedis(SignUpRequest signUpRequest) throws CodeExpiredException, VerificationCodeInvalid, EmaiNotVerifiedOrRequestIdNotValid;
}



=== File: src/main/java/com/falcon/falcon/state/impl/NotStartedState.java ===
package com.falcon.falcon.statePattern.impl;

import com.falcon.falcon.statePattern.InstanceState;
import org.springframework.stereotype.Component;

@Component
public class NotStartedState implements InstanceState {
}



=== File: src/main/java/com/falcon/falcon/state/impl/PausedState.java ===
package com.falcon.falcon.statePattern.impl;

import com.falcon.falcon.statePattern.InstanceState;
import org.springframework.stereotype.Component;

@Component
public class PausedState implements InstanceState {
}



=== File: src/main/java/com/falcon/falcon/state/impl/RunningState.java ===
package com.falcon.falcon.statePattern.impl;

import com.falcon.falcon.statePattern.InstanceState;
import org.springframework.stereotype.Component;

@Component
public class RunningState implements InstanceState {
}



=== File: src/main/java/com/falcon/falcon/state/impl/TerminatedState.java ===
package com.falcon.falcon.statePattern.impl;

import com.falcon.falcon.statePattern.InstanceState;
import org.springframework.stereotype.Component;

@Component
public class TerminatedState implements InstanceState {
}



=== File: src/main/java/com/falcon/falcon/state/InstanceState.java ===
package com.falcon.falcon.statePattern;

public interface InstanceState {
}



=== File: src/test/java/com/falcon/falcon/FalconApplicationTests.java ===
package com.falcon.falcon;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class FalconApplicationTests {
/*
	@Test
	void contextLoads() {
	}
*/
}



